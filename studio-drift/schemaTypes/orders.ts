// schemas/order.ts
import { defineType, defineField } from 'sanity'

export default defineType({
  name: 'order',
  title: 'Order',
  type: 'document',
  fields: [
    defineField({
      name: 'orderNumber',
      title: 'Order Number',
      type: 'string',
      readOnly: true,
      description: 'Unique sequential order number generated by the system.',
    }),
    defineField({
      name: 'customer',
      title: 'Customer Information',
      type: 'object',
      fields: [
        defineField({
          name: 'name',
          title: 'Full Name',
          type: 'string',
        }),
        defineField({
          name: 'phone',
          title: 'Phone Number',
          type: 'string',
          validation: (Rule) => Rule.required()
        }),
        defineField({
          name: 'email',
          title: 'Email',
          type: 'string',
          validation: (Rule) => Rule.email().optional() // Added optional email validation
        }),
        defineField({
          name: 'whatsapp',
          title: 'WhatsApp Number',
          type: 'string',
          description: 'WhatsApp number if different from phone number.',
        })
      ],
      validation: (Rule) => Rule.required() // Customer info object is required
    }),
    defineField({
      name: 'items',
      title: 'Order Items',
      type: 'array',
      of: [
        {
          type: 'object',
          name: 'orderItem', // Give the inline object a name
          fields: [
            defineField({
              name: 'itemId',
              title: 'Frontend Item ID',
              type: 'string',
              readOnly: true,
              description: 'Unique ID generated by the frontend for this specific configuration (meal + size + choices).',
              validation: (Rule) => Rule.required() // itemId should be required
            }),
             defineField({
              name: 'product',
              title: 'Product Reference',
              type: 'reference',
              to: [{ type: 'meal' }, { type: 'combo' }], // Assuming combos might be used later
              description: 'Reference to the original Meal or Combo document.',
              validation: (Rule) => Rule.required()
            }),
            defineField({
              name: 'nameAtPurchase',
              title: 'Name at Purchase',
              type: 'string',
              description: 'Generated display name of the product at the time of ordering (includes size/choices).',
              readOnly: true,
              validation: (Rule) => Rule.required()
            }),
             defineField({
              name: 'basePriceAtPurchase',
              title: 'Base Price (at purchase)',
              type: 'number',
              description: 'Price of the selected size or base meal price at time of ordering.',
              readOnly: true,
              validation: (Rule) => Rule.required().min(0) // Price can be 0
            }),
            defineField({
              name: 'quantity',
              title: 'Quantity',
              type: 'number',
              initialValue: 1,
              validation: (Rule) => Rule.required().min(1)
            }),

            defineField({
              name: 'selectedSizeAtPurchase',
              title: 'Selected Size',
              type: 'object',
              readOnly: true,
              description: 'Details of the size selected at the time of ordering.',
              fields: [
                 defineField({ name: 'label', title: 'Label', type: 'string' }),
                 defineField({ name: 'price', title: 'Price', type: 'number' }),
                 // Renamed from '_key' to 'sizeKey'
                 defineField({ name: 'sizeKey', title: 'Key', type: 'string', description: 'Sanity key for the size option.' })
              ],
              validation: (Rule) => Rule.optional()
            }),
            defineField({
              name: 'selectedChoicesAtPurchase',
              title: 'Selected Choices',
              type: 'array',
              readOnly: true,
              description: 'Details of the options selected for each choice group at the time of ordering.',
              of: [
                {
                  type: 'object',
                  name: 'selectedChoiceGroup', // Give inline object a name
                  fields: [
                    // Renamed from '_ref' to 'choiceGroupId'
                    defineField({
                       name: 'choiceGroupId',
                       title: 'Choice Group Ref',
                       type: 'string', // Storing the ID as a string
                       description: 'Reference ID of the original Choice group document.'
                    }),
                    defineField({
                       name: 'choiceName',
                       title: 'Choice Group Name',
                       type: 'string', // Store the name
                    }),
                    defineField({
                      name: 'selectedOptions',
                      title: 'Selected Options',
                      type: 'array',
                      of: [
                        {
                           type: 'object',
                           name: 'selectedChoiceOption', // Give inline object a name
                           fields: [
                              // Renamed from '_key' to 'optionKey'
                              defineField({ name: 'optionKey', title: 'Key', type: 'string', description: 'Sanity key for the option.' }),
                              defineField({ name: 'name', title: 'Name', type: 'string' }),
                              defineField({ name: 'price', title: 'Price Adjustment', type: 'number' }),
                           ],
                           preview: {
                              select: {
                                 name: 'name',
                                 price: 'price',
                              },
                              prepare(selection) {
                                 const { name, price } = selection;
                                 return {
                                    title: name,
                                    subtitle: price !== undefined && price !== null ? `+R${price.toFixed(2)}` : '',
                                 };
                              },
                           },
                        }
                      ]
                    })
                  ],
                   preview: {
                      select: {
                         name: 'choiceName',
                         options: 'selectedOptions',
                      },
                       prepare(selection) {
                          const { name, options } = selection;
                           const optionNames = options?.map((opt: any) => opt.name).join(', ') || 'No options';
                           return {
                              title: name,
                              subtitle: optionNames,
                           };
                      },
                   },
                }
              ],
              validation: (Rule) => Rule.optional()
            }),
            defineField({
              name: 'selectedExtras',
              title: 'Selected Extras',
              type: 'array',
               description: 'List of extras selected for each quantity unit.',
              of: [
                {
                  type: 'object',
                  name: 'selectedExtraUnit', // Give the inline object a name
                  fields: [
                     defineField({
                       name: 'extra',
                       title: 'Extra Item',
                       type: 'reference',
                       to: [{ type: 'extra' }],
                       description: 'Reference to the original Extra document.',
                       validation: (Rule) => Rule.required()
                     }),
                    defineField({
                      name: 'name',
                      title: 'Name at Purchase',
                      type: 'string',
                      readOnly: true, // Store name at purchase time
                      validation: (Rule) => Rule.required()
                    }),
                    defineField({
                      name: 'price',
                      title: 'Price at Purchase',
                      type: 'number',
                      readOnly: true, // Store price at purchase time
                      validation: (Rule) => Rule.required().min(0)
                    }),
                    defineField({
                      name: 'quantityIndex',
                      title: 'For Unit #',
                      type: 'number',
                      description: 'The index of the quantity unit this extra applies to (0-based index).',
                       validation: (Rule) => Rule.required().min(0).integer()
                    }),
                  ],
                   preview: {
                      select: {
                         name: 'name',
                         price: 'price',
                         index: 'quantityIndex'
                      },
                      prepare(selection) {
                         const { name, price, index } = selection;
                          return {
                             title: `${name} (+R${price?.toFixed(2) || '0.00'})`,
                             subtitle: `For Unit #${index + 1}`,
                          };
                      },
                   },
                }
              ]
            }),
            defineField({
              name: 'image',
              title: 'Product Image at Purchase',
              type: 'image', // Store the image data at time of purchase
              options: {
                hotspot: true
              },
              readOnly: true,
              description: 'Image of the product at the time of ordering.',
               // No validation needed for an optional image field
            })
          ],
           preview: {
              select: {
                 name: 'nameAtPurchase',
                 quantity: 'quantity',
                 basePrice: 'basePriceAtPurchase',
                 selectedSizeLabel: 'selectedSizeAtPurchase.label', // Select the label
              },
              prepare(selection) {
                 const { name, quantity, basePrice, selectedSizeLabel } = selection;
                  const subtitleParts = [];
                  if(quantity !== undefined) subtitleParts.push(`Qty: ${quantity}`);
                   // Base price might be unit price before options if no size
                   // Or it's the selected size price
                  if (basePrice !== undefined && basePrice !== null) subtitleParts.push(`Base: R${basePrice.toFixed(2)}`);
                  if (selectedSizeLabel) subtitleParts.push(`Size: ${selectedSizeLabel}`);

                  // A custom preview component would be needed to summarize choices/extras nicely

                 return {
                    title: name || 'Unnamed Item',
                    subtitle: subtitleParts.join(' • '),
                 };
              },
           },
        }
      ],
      validation: (Rule) => Rule.required().min(1) // At least one item is required
    }),
    defineField({
      name: 'status',
      title: 'Order Status',
      type: 'string',
      options: {
        list: [
          {title: 'Received', value: 'received'},
          {title: 'Preparing', value: 'preparing'},
          {title: 'Ready for Pickup', value: 'ready'},
          {title: 'Completed', value: 'completed'},
          {title: 'Cancelled', value: 'cancelled'}
        ]
      },
      initialValue: 'received',
      validation: (Rule) => Rule.required()
    }),
    defineField({
      name: 'paymentMethod',
      title: 'Payment Method',
      type: 'string',
      options: {
        list: [
          {title: 'eWallet', value: 'eWallet'},             // Updated value
          {title: 'MoMo', value: 'MoMo'},                 // Updated value
          {title: 'Cash on Collect', value: 'Cash on Collect'} // Updated value
        ],
        layout: 'radio'
      },
      initialValue: 'Cash on Collect', // Updated initial value
      validation: (Rule) => Rule.required()
    }),
    defineField({
      name: 'paymentStatus',
      title: 'Payment Status',
      type: 'string',
      options: {
        list: [
          {title: 'Pending', value: 'pending'},
          {title: 'Paid', value: 'paid'},
          {title: 'Refunded', value: 'refunded'}
        ]
      },
      initialValue: 'pending',
      validation: (Rule) => Rule.required()
    }),
    defineField({
      name: 'totalAmount',
      title: 'Total Amount',
      type: 'number',
       description: 'Calculated total amount for the order including all items, sizes, choices, and extras.',
      validation: (Rule) => Rule.required().min(0) // Total can be 0 if items are free, etc.
    }),
    defineField({
      name: 'notes',
      title: 'Special Instructions',
      type: 'text',
       description: 'Any special instructions added by the customer.',
    }),
    defineField({
      name: 'orderDate',
      title: 'Order Date & Time',
      type: 'datetime',
      initialValue: (new Date()).toISOString(),
      validation: (Rule) => Rule.required()
    }),
    defineField({
      name: 'estimatedReady',
      title: 'Estimated Ready Time',
      type: 'datetime',
       description: 'Estimated time when the order will be ready for pickup/delivery.',
    }),
    defineField({
      name: 'paymentProof',
      title: 'Payment Proof',
      type: 'image',
      options: {
        hotspot: true
      },
      description: 'Uploaded image or document proving payment.',
       validation: (Rule) => Rule.optional() // Proof is optional depending on payment method
    })
  ],
  initialValue: {
    orderDate: (new Date()).toISOString(),
    status: 'received', // Ensure initial status is set
    paymentStatus: 'pending', // Ensure initial payment status is set
  },
  preview: {
    select: {
      customerName: 'customer.name',
      phoneNumber: 'customer.phone',
      itemsCount: 'items.length',
      total: 'totalAmount',
      status: 'status',
      payment: 'paymentMethod',
      orderNumber: 'orderNumber',
      orderDate: 'orderDate'
    },
    prepare(selection) {
      const { customerName, phoneNumber, itemsCount, total, status, payment, orderNumber, orderDate } = selection;
       const date = orderDate ? new Date(orderDate).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'No date';

      return {
        title: `${orderNumber ? `#${orderNumber} - ` : ''}${customerName || phoneNumber || 'New Order'}`,
        subtitle: `${itemsCount} item(s) • R${total?.toFixed(2) || '0.00'} • ${status} • ${payment} • ${date}`,
      }
    }
  }
})